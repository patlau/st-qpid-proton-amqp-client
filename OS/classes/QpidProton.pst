<?xml version="1.0"?><st-source><!-- Name: QpidProtonDbIdentifier: VE2000DbTrace: 11828DbUsername: zhlpcDbVersion: 0.14PackageName: QpidProtonParcel: #('QpidProton')PrintStringCache: (0.14,zhlpc)Version: 0.14Date: 3:44:37 PM October 21, 2015 --><time-stamp>From VisualWorksÂ®, 8.1 of 24. Juli 2015 on 21. Oktober 2015 at 15:44:37</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>QPID</name><environment>ObjectStudio</environment><private>false</private><imports>			private Core.*			</imports><category></category><attributes><package>QpidProton</package></attributes></name-space><class><name>QpidProton</name><environment>ObjectStudio</environment><super>ObjectStudio.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>freeOnFinalize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><class><name>QpidProtonError</name><environment>ObjectStudio</environment><super>ObjectStudio.QpidProton</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pn_error_t </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><class><name>QpidProtonMessenger</name><environment>ObjectStudio</environment><super>ObjectStudio.QpidProton</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pn_messenger_t </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><class><name>QpidProtonSubscription</name><environment>ObjectStudio</environment><super>ObjectStudio.QpidProton</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pn_subscription_t </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><class><name>QpidProtonDLL</name><environment>ObjectStudio</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private ObjectStudio.QpidProtonDLLDictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>qpid-proton.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>QpidProton</package></attributes></class><class><name>QpidProtonData</name><environment>ObjectStudio</environment><super>ObjectStudio.QpidProton</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pn_data_t </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><class><name>QpidProtonMessage</name><environment>ObjectStudio</environment><super>ObjectStudio.QpidProton</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pn_message_t </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>As yet unclassified</category><attributes><package>QpidProton</package></attributes></class><shared-variable><name>instances</name><environment>ObjectStudio.QpidProton</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>QpidProton</package></attributes></shared-variable><shared-variable><name>QpidProtonDLLDictionary</name><environment>ObjectStudio</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>QpidProton</package></attributes></shared-variable><shared-variable><name>QpidProtonLibrary</name><environment>ObjectStudio</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>QpidProton</package></attributes></shared-variable><methods><class-id>ObjectStudio.QpidProton</class-id> <category>methods</category><body package="QpidProton">destroy	self log: #trace key: self class name msg: 'Destroy (freeOnFinalize=' + (freeOnFinalize ~= false) + ')'.	freeOnFinalize ~= false ifTrue: [		(self respondsTo: #free) ifTrue: [self free].	].	instances remove: self.</body><body package="QpidProton">finalize	self log: #trace key: self class name msg: 'Finalize'.	self destroy.</body><body package="QpidProton">freeOnFinalize: aBoolean	self log: #trace key: self class name msg: 'FreeOnFinalize:' ++ aBoolean.	freeOnFinalize := aBoolean.</body><body package="QpidProton">log: traceSymbol key: keySymbol msg: msgStringOrSymbol"	(keySymbol asString + '&gt;&gt;' + msgStringOrSymbol) out."</body></methods><methods><class-id>ObjectStudio.QpidProton class</class-id> <category>methods</category><body package="QpidProton">errorCodes"	#defines are currently not generated. So we define this here."	^(IdentityDictionary new)		at: #PN_OK put: (0);		at: #PN_EOS put: (-1);		at: #PN_ERR put: (-2);		at: #PN_OVERFLOW put: (-3);		at: #PN_UNDERFLOW put: (-4);		at: #PN_STATE_ERR put: (-5);		at: #PN_ARG_ERR put: (-6);		at: #PN_TIMEOUT put: (-7);		at: #PN_INTR put: (-8);		at: #PN_INPROGRESS put: (-9);		at: #PN_OUT_OF_MEMORY put: (-10);		yourself.</body><body package="QpidProton">errorMessageForCode: anInteger	^QpidProtonLibrary pn_code: anInteger.</body><body package="QpidProton">errorSymbolForCode: anInteger	^self errorCodes keyAt: anInteger.</body><body package="QpidProton">initialize	instances := WeakIdentitySet new.</body><body package="QpidProton">new	| obj |		(self name asString + '&gt;&gt;new') out.		obj := super new.		"Do not free Data objects, because they are normally freed by the message object"	self name = #QpidProtonData ifTrue: [		obj freeOnFinalize: false.	].		instances add: obj.		^obj.</body></methods><methods><class-id>ObjectStudio.QpidProtonError</class-id> <category>methods</category><body package="QpidProton">clear""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_clear: pn_error_t "pn_error_t*".</body><body package="QpidProton">code""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_code: pn_error_t "pn_error_t*".</body><body package="QpidProton">copy""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_copy: pn_error_t "pn_error_t*"		with: pn_error_t "pn_error_t*".</body><body package="QpidProton">destroy	pn_error_t ifNil: [^self].	super destroy.	pn_error_t := nil.</body><body package="QpidProton">error: code text: text""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_set: pn_error_t "pn_error_t*"		with: code "int"		with: text "const char*".</body><body package="QpidProton">format: code fmt: fmt list: list""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_format: pn_error_t "pn_error_t*"		with: code "int"		with: fmt "const char*"		with: list "array".</body><body package="QpidProton">free""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_free: pn_error_t "pn_error_t*".</body><body package="QpidProton">pn_error_t	^pn_error_t.</body><body package="QpidProton">text""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_text: pn_error_t "pn_error_t*".</body><body package="QpidProton">vformat: code fmt: fmt ap: ap""	pn_error_t ifNil: [^nil].	^QpidProtonLibrary 		pn_error_vformat: pn_error_t "pn_error_t*"		with: code "int"		with: fmt "const char*"		with: ap "va_list".</body></methods><methods><class-id>ObjectStudio.QpidProtonError class</class-id> <category>methods</category><body package="QpidProton">new""	^self new: (QpidProtonLibrary 		pn_error).</body><body package="QpidProton">new: pn_error_t	| obj |	obj := super new.	obj varAt: #pn_error_t put: pn_error_t.	^obj.</body></methods><methods><class-id>ObjectStudio.QpidProtonMessenger</class-id> <category>methods</category><body package="QpidProton">accept: tracker flags: flags" Signal successful processing of message(s). With no flags this operation will signal the sender that the message referenced by the tracker was accepted. If the PN_CUMULATIVE flag is set, this operation will also reject all pending messages prior to the message indicated by the tracker. Note that when a message is accepted or rejected multiple times, either explicitly, or implicitly through use of the ::PN_CUMULATIVE flag, only the first outcome applies. For example if a sequence of three messages are received: M1, M2, M3, and M2 is rejected, and M3 is cumulatively accepted, M2 will remain rejected and only M1 and M3 will be considered accepted. @param[in] messenger a messenger object @param[in] tracker an incoming tracker @param[in] flags 0 or PN_CUMULATIVE @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_accept: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t"		with: flags "int".</body><body package="QpidProton">blocking" Check if a messenger is in blocking mode. @param[in] messenger a messenger object @return true if blocking has been enabled, false otherwise"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_is_blocking: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">blocking: blocking" Enable or disable blocking behavior for a messenger during calls to ::pn_messenger_send and ::pn_messenger_recv. @param[in] messenger a messenger object @param[in] blocking the value of the blocking flag @return an error code or zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_blocking: pn_messenger_t "pn_messenger_t*"		with: blocking "bool".</body><body package="QpidProton">buffered: tracker" Check if the delivery associated with a given tracker is still waiting to be sent. Note that returning false does not imply that the delivery was actually sent over the wire. @param[in] messenger the messenger @param[in] tracker the tracker identifying the delivery @return true if the delivery is still buffered"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_buffered: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t".</body><body package="QpidProton">certificate" Get the certificate path. This value may be set by pn_messenger_set_certificate. The default certificate path is null. @param[in] messenger the messenger @return the certificate file path"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_certificate: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">certificate: certificate" Sets the path that will be used to get the certificate that will be used to identify this messenger to its peers. The validity of the path is not checked by this function. @param[in] messenger the messenger @param[in] certificate a path to a certificate file @return an error code of zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_certificate: pn_messenger_t "pn_messenger_t*"		with: certificate "const char*".</body><body package="QpidProton">deadline" Get the nearest deadline for selectables associated with a messenger. @param[in] messenger a messenger object @return the nearest deadline"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_deadline: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">delivery: tracker" Get delivery information about a delivery. Returns the delivery information associated with the supplied tracker. This may return NULL if the tracker has fallen outside the incoming/outgoing tracking windows of the messenger. @param[in] messenger the messenger @param[in] tracker the tracker identifying the delivery @return a pn_delivery_t representing the delivery."	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_delivery: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t".</body><body package="QpidProton">destroy	pn_messenger_t ifNil: [^self].	super destroy.	pn_messenger_t := nil.</body><body package="QpidProton">errno" Get the code for a messenger's most recent error. The error code is initialized to zero at messenger creation. The error number is 'sticky' i.e. error codes are not reset to 0 at the end of successful API calls. You can use ::pn_messenger_error to access the messenger's error object and clear explicitly if desired. @param[in] messenger the messenger to check for errors @return an error code or zero if there is no error @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_errno: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">error" Get a messenger's error object. Returns a pointer to a pn_error_t that is valid until the messenger is freed. The pn_error_* API allows you to access the text, error number, and lets you set or clear the error code explicitly. @param[in] messenger the messenger to check for errors @return a pointer to the messenger's error descriptor @see error.h"	^QpidProtonError new: (self private_error).</body><body package="QpidProton">flags" @param[in] messenger the messenger @return The flags set for the messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_flags: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">flags: flags" @param[in] messenger the messenger @param[in] flags 0 or PN_FLAGS_CHECK_ROUTES @return an error code of zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_flags: pn_messenger_t "pn_messenger_t*"		with: flags "const int".</body><body package="QpidProton">free" @param[in] messenger the messenger to free (or NULL), no longer                      valid on return"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_free: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">get: message" Get the next message from the head of a messenger's incoming queue. The get operation copies the message data from the head of the messenger's incoming queue into the provided ::pn_message_t object. If provided ::pn_message_t pointer is NULL, the head essage will be discarded. This operation will return ::PN_EOS if there are no messages left on the incoming queue. @param[in] messenger a messenger object @param[out] message upon return contains the message from the head of the queue @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get: pn_messenger_t "pn_messenger_t*"		with: ((message respondsTo: #pn_message_t) ifTrue: [message pn_message_t] ifFalse: [message]) "pn_message_t*".</body><body package="QpidProton">incoming" Get the number of messages in the incoming message queue of a messenger. @param[in] messenger a messenger object @return the incoming queue depth"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_incoming: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">incomingSubscription" Get the subscription of the message most recently retrieved by ::pn_messenger_get(). This operation will return NULL if ::pn_messenger_get() has never been succesfully called. @param[in] messenger a messenger object @return a pn_subscription_t or NULL"	^QpidProtonSubscription new: (self private_incomingSubscription).</body><body package="QpidProton">incomingTracker" Get a tracker for the message most recently retrieved by ::pn_messenger_get(). A tracker for an incoming message allows you to accept or reject the associated message. It can also be used for cumulative accept/reject operations for the associated message and all prior messages as well. @param[in] messenger a messenger object @return a pn_tracker_t or an undefined value if pn_messenger_get         has never been called for the given messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_incoming_tracker: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">incomingWindow" Get the size of a messenger's incoming window. The size of a messenger's incoming window limits the number of messages that can be accepted or rejected using trackers. Messagesdo not* enter this window when they have been received (::pn_messenger_recv) onto you incoming queue. Messages only enter this window only when you access them using pn_messenger_get. If your incoming window size is N, and you get N+1 messages without explicitly accepting or rejecting the oldest message, then it will be implicitly accepted when it falls off the edge of the incoming window. The default incoming window size is 0. @param[in] messenger a messenger object @return the incoming window for the messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_incoming_window: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">incomingWindow: window" Set the size of a messenger's incoming window. See ::pn_messenger_get_incoming_window() for details. @param[in] messenger a messenger object @param[in] window the number of deliveries to track @return an error or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_incoming_window: pn_messenger_t "pn_messenger_t*"		with: window "int".</body><body package="QpidProton">interrupt" Interrupt a messenger object that may be blocking in another thread. The messenger interface is single-threaded. This is the only messenger function intended to be concurrently called from another thread. It will interrupt any messenger function which is currently blocking and cause it to return with a status of ::PN_INTR. @param[in] messenger the Messenger to interrupt"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_interrupt: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">link: address sender: sender" Get a link based on link name and whether the link is a sender or receiver @param[in] messenger the messenger to get the link from @param[in] address the link address that identifies the link to receive @param[in] sender true if the link is a sender, false if the link is a            receiver @return a link, or NULL if no link matches the address / sender parameters"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_link: pn_messenger_t "pn_messenger_t*"		with: address "const char*"		with: sender "bool".</body><body package="QpidProton">name" Get the name of a messenger. @param[in] messenger a messenger object @return the name of the messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_name: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">outgoing" Get the number of messages in the outgoing message queue of a messenger. @param[in] messenger a messenger object @return the outgoing queue depth"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_outgoing: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">outgoingTracker" Get a tracker for the outgoing message most recently given to pn_messenger_put. This tracker may be used with pn_messenger_status to determine the delivery status of the message, as long as the message is still within your outgoing window. @param[in] messenger the messenger @return a pn_tracker_t or an undefined value if pn_messenger_get         has never been called for the given messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_outgoing_tracker: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">outgoingWindow" Get the size of a messenger's outgoing window. The size of the outgoing window limits the number of messages whose status you can check with a tracker. A message enters this window when you call pn_messenger_put on the message. For example, if your outgoing window size is 10, and you call pn_messenger_put 12 times, new status information will no longer be available for the first 2 messages. The default outgoing window size is 0. @param[in] messenger a messenger object @return the outgoing window for the messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_outgoing_window: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">outgoingWindow: window" Set the size of a messenger's outgoing window. See ::pn_messenger_get_outgoing_window() for details. @param[in] messenger a messenger object @param[in] window the number of deliveries to track @return an error or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_outgoing_window: pn_messenger_t "pn_messenger_t*"		with: window "int".</body><body package="QpidProton">passive" Check if a messenger is in passive mode. A messenger that is in passive mode will never attempt to perform I/O internally, but instead will make all internal file descriptors accessible through ::pn_messenger_selectable() to be serviced externally. This can be useful for integrating messenger into an external event loop. @param[in] messenger a messenger object @return true if the messenger is in passive mode, false otherwise"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_is_passive: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">passive: passive" Set the passive mode for a messenger. See ::pn_messenger_is_passive() for details on passive mode. @param[in] messenger a messenger object @param[in] passive true to enable passive mode, false to disable passive mode @return an error code or zero on success"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_passive: pn_messenger_t "pn_messenger_t*"		with: passive "bool".</body><body package="QpidProton">password" Gets the private key file password for a messenger. @param[in] messenger a messenger object @return password for the private key file"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_password: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">password: password" Sets the private key password for a messenger. @param[in] messenger a messenger object @param[in] password the password for the private key file @return an error code of zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_password: pn_messenger_t "pn_messenger_t*"		with: password "const char*".</body><body package="QpidProton">pn_messenger_t	^pn_messenger_t.</body><body package="QpidProton">privateKey" Gets the private key file for a messenger. @param[in] messenger a messenger object @return the messenger's private key file path"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_private_key: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">privateKey: private_key" Set path to the private key that was used to sign the certificate. See ::pn_messenger_set_certificate @param[in] messenger a messenger object @param[in] private_key a path to a private key file @return an error code of zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_private_key: pn_messenger_t "pn_messenger_t*"		with: private_key "const char*".</body><body package="QpidProton">private_error" Get a messenger's error object. Returns a pointer to a pn_error_t that is valid until the messenger is freed. The pn_error_* API allows you to access the text, error number, and lets you set or clear the error code explicitly. @param[in] messenger the messenger to check for errors @return a pointer to the messenger's error descriptor @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_error: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">private_incomingSubscription" Get the subscription of the message most recently retrieved by ::pn_messenger_get(). This operation will return NULL if ::pn_messenger_get() has never been succesfully called. @param[in] messenger a messenger object @return a pn_subscription_t or NULL"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_incoming_subscription: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">private_subscribe: source" Subscribes a messenger to messages from the specified source. @param[in] messenger the messenger to subscribe @param[in] source @return a subscription"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_subscribe: pn_messenger_t "pn_messenger_t*"		with: source "const char*".</body><body package="QpidProton">private_subscribeTtl: source timeout: timeout" Subscribes a messenger to messages from the specified source with the given timeout for the subscription's lifetime. @param[in] messenger the messenger to subscribe @param[in] source @param[in] timeout the maximum time to keep the subscription alive once the            link is closed. @return a subscription"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_subscribe_ttl: pn_messenger_t "pn_messenger_t*"		with: source "const char*"		with: timeout "pn_seconds_t".</body><body package="QpidProton">put: msg" Puts a message onto the messenger's outgoing queue. The message may also be sent if transmission would not cause blocking. This call will not block. @param[in] messenger a messenger object @param[in] msg a message to put on the messenger's outgoing queue @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_put: pn_messenger_t "pn_messenger_t*"		with: ((msg respondsTo: #pn_message_t) ifTrue: [msg pn_message_t] ifFalse: [msg]) "pn_message_t*".</body><body package="QpidProton">rcvSettleMode: mode" Set the local receiver settle mode for the underlying link. @param[in] messenger the messenger @param[in] mode the receiver settle mode"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_rcv_settle_mode: pn_messenger_t "pn_messenger_t*"		with: mode "const pn_rcv_settle_mode_t".</body><body package="QpidProton">receiving" Get the capacity of the incoming message queue of a messenger. Note this count does not include those messages already available on the incoming queue (@see pn_messenger_incoming()). Rather it returns the number of incoming queue entries available for receiving messages. @param[in] messenger the messenger"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_receiving: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">recv: limit" Retrieve messages into a messenger's incoming queue. Instructs a messenger to receive up to @c limit messages into the incoming message queue of a messenger. If @c limit is -1, the messenger will receive as many messages as it can buffer internally. If the messenger is in blocking mode, this call will block until at least one message is available in the incoming queue. Each call to pn_messenger_recv replaces the previous receive operation, so pn_messenger_recv(messenger, 0) will cancel any outstanding receive. After receiving messages onto your incoming queue use ::pn_messenger_get() to access message content. @param[in] messenger the messenger @param[in] limit the maximum number of messages to receive or -1 to                  to receive as many messages as it can buffer                  internally. @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_recv: pn_messenger_t "pn_messenger_t*"		with: limit "int".</body><body package="QpidProton">reject: tracker flags: flags" Signal unsuccessful processing of message(s). With no flags this operation will signal the sender that the message indicated by the tracker was rejected. If the PN_CUMULATIVE flag is used this operation will also reject all pending messages prior to the message indicated by the tracker. Note that when a message is accepted or rejected multiple times, either explicitly, or implicitly through use of the ::PN_CUMULATIVE flag, only the first outcome applies. For example if a sequence of three messages are received: M1, M2, M3, and M2 is accepted, and M3 is cumulatively rejected, M2 will remain accepted and only M1 and M3 will be considered rejected. @param[in] messenger a messenger object @param[in] tracker an incoming tracker @param[in] flags 0 or PN_CUMULATIVE @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_reject: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t"		with: flags "int".</body><body package="QpidProton">remoteIdleTimeout: address" Gets the remote idle timeout for the specified remote service address @param[in] messenger a messenger object @param[in] address of remote service whose idle timeout is required @return the timeout in milliseconds or -1 if an error occurs"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_remote_idle_timeout: pn_messenger_t "pn_messenger_t*"		with: address "const char*".</body><body package="QpidProton">rewrite: pattern address: address" Rewrite message addresses prior to transmission. This operation is similar to pn_messenger_route, except that the destination of the message is determined before the message address is rewritten. The outgoing address is only rewritten after routing has been finalized.  If a message has an outgoing address of 'amqp://0.0.0.0:5678', and a rewriting rule that changes its outgoing address to 'foo', it will still arrive at the peer that is listening on 'amqp://0.0.0.0:5678', but when it arrives there, the receiver will see its outgoing address as 'foo'. The default rewrite rule removes username and password from addresses before they are transmitted. @param[in] messenger a messenger object @param[in] pattern a glob pattern to select messages @param[in] address an address indicating outgoing address rewrite @return an error code or zero on success"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_rewrite: pn_messenger_t "pn_messenger_t*"		with: pattern "const char*"		with: address "const char*".</body><body package="QpidProton">route: pattern address: address""	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_route: pn_messenger_t "pn_messenger_t*"		with: pattern "const char*"		with: address "const char*".</body><body package="QpidProton">selectable" Extract @link pn_selectable_t selectables @endlink from a passive messenger. A messenger that is in passive mode (see ::pn_messenger_is_passive()) will never attempt to perform any I/O internally, but instead make its internal file descriptors available for external processing via the ::pn_messenger_selectable() operation. An application wishing to perform I/O on behalf of a passive messenger must extract all available selectables by calling this operation until it returns NULL. The ::pn_selectable_t interface may then be used by the application to perform I/O outside the messenger. All selectables returned by this operation must be serviced until they reach a terminal state and then freed. See ::pn_selectable_is_terminal() for more details. By default any given selectable will only ever be returned once by this operation, however if the selectable's registered flag is set to true (see ::pn_selectable_set_registered()), then the selectable will be returned whenever its interest set may have changed. @param[in] messenger a messenger object @return the next selectable, or NULL if there are none left"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_selectable: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">send: n" Send messages from a messenger's outgoing queue. If a messenger is in blocking mode (see ::pn_messenger_is_blocking()), this operation will block until N messages have been sent from the outgoing queue. A value of -1 for N means 'all messages in the outgoing queue'. See below for a full definition of what sent from the outgoing queue means. Any blocking will end once the messenger's configured timeout (if any) has been reached. When this happens an error code of ::PN_TIMEOUT is returned. If the messenger is in non blocking mode, this call will return an error code of ::PN_INPROGRESS if it is unable to send the requested number of messages without blocking. A message is considered to be sent from the outgoing queue when its status has been fully determined. This does not necessarily mean the message was successfully sent to the final recipient though, for example of the receiver rejects the message, the final status will be ::PN_STATUS_REJECTED. Similarly, if a message is sent to an invalid address, it may be removed from the outgoing queue without ever even being transmitted. In this case the final status will be ::PN_STATUS_ABORTED. @param[in] messenger a messenger object @param[in] n the number of messages to send @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_send: pn_messenger_t "pn_messenger_t*"		with: n "int".</body><body package="QpidProton">sndSettleMode: mode" Set the local sender settle mode for the underlying link. @param[in] messenger the messenger @param[in] mode the sender settle mode"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_snd_settle_mode: pn_messenger_t "pn_messenger_t*"		with: mode "const pn_snd_settle_mode_t".</body><body package="QpidProton">sslPeerAuthenticationMode: mode" Sets the SSL peer authentiacation mode required when a trust certificate is used. @param[in] messenger a messenger object @param[in] mode the mode required (see pn_ssl_verify_mode_t             enum for valid values) @return 0 if successful or -1 if an error occurs"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_ssl_peer_authentication_mode: pn_messenger_t "pn_messenger_t*"		with: mode "const pn_ssl_verify_mode_t".</body><body package="QpidProton">start" Currently a no-op placeholder. For future compatibility, do not send or receive messages before starting the messenger. @param[in] messenger the messenger to start @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_start: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">status: tracker" Track the status of a delivery. Get the current status of the delivery associated with the supplied tracker. This may return PN_STATUS_UNKOWN if the tracker has fallen outside the incoming/outgoing tracking windows of the messenger. @param[in] messenger the messenger @param[in] tracker the tracker identifying the delivery @return a status code for the delivery"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_status: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t".</body><body package="QpidProton">stop" Stops a messenger. Stopping a messenger will perform an orderly shutdown of all underlying connections. This may require some time. If the messenger is in non blocking mode (see ::pn_messenger_is_blocking), this operation will return PN_INPROGRESS if it cannot finish immediately. In that case, you can use ::pn_messenger_stopped() to determine when the messenger has finished stopping. @param[in] messenger the messenger to stop @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_stop: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">stopped" Returns true if a messenger is in the stopped state. This function does not block. @param[in] messenger the messenger to stop"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_stopped: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">subscribe: source" Subscribes a messenger to messages from the specified source. @param[in] messenger the messenger to subscribe @param[in] source @return a subscription"	^QpidProtonSubscription new: (self private_subscribe: source).</body><body package="QpidProton">subscribeTtl: source timeout: timeout" Subscribes a messenger to messages from the specified source with the given timeout for the subscription's lifetime. @param[in] messenger the messenger to subscribe @param[in] source @param[in] timeout the maximum time to keep the subscription alive once the            link is closed. @return a subscription"	^QpidProtonSubscription new: (self private_subscribeTtl: source timeout: timeout).</body><body package="QpidProton">timeout" Gets the timeout for a messenger object. See ::pn_messenger_set_timeout() for details. @param[in] messenger a messenger object @return the timeout for the messenger, in milliseconds"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_timeout: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">timeout: timeout" Set the default timeout for a messenger. Any messenger call that blocks during execution will stop blocking and return control when this timeout is reached, if you have set it to a value greater than zero. The timeout is expressed in milliseconds. @param[in] messenger a messenger object @param[in] timeout a new timeout for the messenger, in milliseconds @return an error code or zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_timeout: pn_messenger_t "pn_messenger_t*"		with: timeout "int".</body><body package="QpidProton">tle: tracker flags: flags" Frees a Messenger from tracking the status associated with a given tracker. Use the PN_CUMULATIVE flag to indicate everything up to (and including) the given tracker. @param[in] messenger the Messenger @param[in] tracker identifies a delivery @param[in] flags 0 or PN_CUMULATIVE @return an error code or zero on success @see error.h"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_settle: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t"		with: flags "int".</body><body package="QpidProton">tracer: tracer" Set the tracer associated with a messenger. @param[in] messenger a messenger object @param[in] tracer the tracer callback"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_tracer: pn_messenger_t "pn_messenger_t*"		with: tracer "pn_tracer_t".</body><body package="QpidProton">trackerLink: tracker" Get  link for the message referenced by the given tracker. @param[in] messenger a messenger object @param[in] tracker a tracker object @return a pn_link_t or NULL if the link could not be determined."	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_tracker_link: pn_messenger_t "pn_messenger_t*"		with: tracker "pn_tracker_t".</body><body package="QpidProton">trustedCertificates" Gets the trusted certificates database for a messenger. @param[in] messenger a messenger object @return path to the trusted certificates database"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_get_trusted_certificates: pn_messenger_t "pn_messenger_t*".</body><body package="QpidProton">trustedCertificates: cert_db" Sets the trusted certificates database for a messenger. The messenger will use this database to validate the certificate provided by the peer. @param[in] messenger a messenger object @param[in] cert_db a path to the certificates database @return an error code of zero if there is no error"	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_set_trusted_certificates: pn_messenger_t "pn_messenger_t*"		with: cert_db "const char*".</body><body package="QpidProton">work: timeout" Sends or receives any outstanding messages queued for a messenger. This will block for the indicated timeout. @param[in] messenger the Messenger @param[in] timeout the maximum time to block in milliseconds, -1 == forever, 0 == do not block @return 0 if no work to do, &lt; 0 if error, or 1 if work was done."	pn_messenger_t ifNil: [^nil].	^QpidProtonLibrary 		pn_messenger_work: pn_messenger_t "pn_messenger_t*"		with: timeout "int".</body></methods><methods><class-id>ObjectStudio.QpidProtonMessenger class</class-id> <category>methods</category><body package="QpidProton">new: pn_messenger_t	| obj |	obj := super new.	obj varAt: #pn_messenger_t put: pn_messenger_t.	^obj.</body><body package="QpidProton">newName: name" Construct a new ::pn_messenger_t with the given name. The name is global. If a NULL name is supplied, a UUID based name will be chosen. @param[in] name the name of the messenger or NULL @return pointer to a new ::pn_messenger_t"	^self new: (QpidProtonLibrary 		pn_messenger: name "const char*").</body></methods><methods><class-id>ObjectStudio.QpidProtonSubscription</class-id> <category>methods</category><body package="QpidProton">address" Get the source address of a subscription. @param[in] sub a subscription object @return the subscription's source address"	pn_subscription_t ifNil: [^nil].	^QpidProtonLibrary 		pn_subscription_address: pn_subscription_t "pn_subscription_t*".</body><body package="QpidProton">context" Get a subscription's application context. See ::pn_subscription_set_context(). @param[in] sub a subscription object @return the subscription's application context"	pn_subscription_t ifNil: [^nil].	^QpidProtonLibrary 		pn_subscription_get_context: pn_subscription_t "pn_subscription_t*".</body><body package="QpidProton">context: context" Set an application context for a subscription. @param[in] sub a subscription object @param[in] context the application context for the subscription"	pn_subscription_t ifNil: [^nil].	^QpidProtonLibrary 		pn_subscription_set_context: pn_subscription_t "pn_subscription_t*"		with: context "void*".</body><body package="QpidProton">destroy	pn_subscription_t ifNil: [^self].	super destroy.	pn_subscription_t := nil.</body><body package="QpidProton">pn_subscription_t	^pn_subscription_t.</body></methods><methods><class-id>ObjectStudio.QpidProtonSubscription class</class-id> <category>methods</category><body package="QpidProton">new: pn_subscription_t	| obj |	obj := super new.	obj varAt: #pn_subscription_t put: pn_subscription_t.	^obj.</body></methods><methods><class-id>ObjectStudio.QpidProtonDLL</class-id> <category>structs</category><body package="QpidProton">pn_atom_t	&lt;C: typedef struct struct_pn_atom_t pn_atom_t&gt;</body><body package="QpidProton">pn_bytes_t	&lt;C: typedef struct struct_pn_bytes_t pn_bytes_t&gt;</body><body package="QpidProton">pn_char_t	&lt;C: typedef uint32_t pn_char_t&gt;</body><body package="QpidProton">pn_collector_t	&lt;C: typedef struct struct_pn_collector_t pn_collector_t&gt;</body><body package="QpidProton">pn_connection_t	&lt;C: typedef struct struct_pn_connection_t pn_connection_t&gt;</body><body package="QpidProton">pn_data_t	&lt;C: typedef struct struct_pn_data_t pn_data_t&gt;</body><body package="QpidProton">pn_decimal128_t	&lt;C: typedef struct struct_pn_decimal128_t pn_decimal128_t&gt;</body><body package="QpidProton">pn_decimal32_t	&lt;C: typedef uint32_t pn_decimal32_t&gt;</body><body package="QpidProton">pn_decimal64_t	&lt;C: typedef uint64_t pn_decimal64_t&gt;</body><body package="QpidProton">pn_delivery_t	&lt;C: typedef struct struct_pn_delivery_t pn_delivery_t&gt;</body><body package="QpidProton">pn_error_t	&lt;C: typedef struct struct_pn_error_t pn_error_t&gt;</body><body package="QpidProton">pn_link_t	&lt;C: typedef struct struct_pn_link_t pn_link_t&gt;</body><body package="QpidProton">pn_message_t	&lt;C: typedef struct struct_pn_message_t pn_message_t&gt;</body><body package="QpidProton">pn_messenger_t	&lt;C: typedef struct struct_pn_messenger_t pn_messenger_t&gt;</body><body package="QpidProton">pn_millis_t	&lt;C: typedef uint32_t pn_millis_t&gt;</body><body package="QpidProton">pn_seconds_t	&lt;C: typedef uint32_t pn_seconds_t&gt;</body><body package="QpidProton">pn_sequence_t	&lt;C: typedef int32_t pn_sequence_t&gt;</body><body package="QpidProton">pn_session_t	&lt;C: typedef struct struct_pn_session_t pn_session_t&gt;</body><body package="QpidProton">pn_state_t	&lt;C: typedef int pn_state_t&gt;</body><body package="QpidProton">pn_subscription_t	&lt;C: typedef struct struct_pn_subscription_t pn_subscription_t&gt;</body><body package="QpidProton">pn_timestamp_t	&lt;C: typedef int64_t pn_timestamp_t&gt;</body><body package="QpidProton">pn_tracker_t	&lt;C: typedef int64_t pn_tracker_t&gt;</body><body package="QpidProton">pn_transport_t	&lt;C: typedef struct struct_pn_transport_t pn_transport_t&gt;</body><body package="QpidProton">pn_uuid_t	&lt;C: typedef struct struct_pn_uuid_t pn_uuid_t&gt;</body><body package="QpidProton">struct_pn_atom_t		&lt;C: struct struct_pn_atom_t {  pn_type_t type;  union {    bool as_bool;    uint8_t as_ubyte;    int8_t as_byte;    uint16_t as_ushort;    int16_t as_short;    uint32_t as_uint;    int32_t as_int;    pn_char_t as_char;    uint64_t as_ulong;    int64_t as_long;    pn_timestamp_t as_timestamp;    float as_float;    double as_double;    pn_decimal32_t as_decimal32;    pn_decimal64_t as_decimal64;    pn_decimal128_t as_decimal128;    pn_uuid_t as_uuid;    pn_bytes_t as_bytes;  } u;} &gt;</body><body package="QpidProton">struct_pn_bytes_t		&lt;C: struct struct_pn_bytes_t {  size_t size;  const char *start;} &gt;</body><body package="QpidProton">struct_pn_decimal128_t		&lt;C: struct struct_pn_decimal128_t {  char bytes[16];} &gt;</body><body package="QpidProton">struct_pn_uuid_t		&lt;C: struct struct_pn_uuid_t {  char bytes[16];} &gt;</body></methods><methods><class-id>ObjectStudio.QpidProtonDLL</class-id> <category>initialize-release</category><body package="QpidProton">initialize	super initialize.</body></methods><methods><class-id>ObjectStudio.QpidProtonDLL class</class-id> <category>As yet unclassified</category><body package="QpidProton">pn_format_t" Encoding format for message content."	^(IdentityDictionary new)		at: #PN_DATA put: 0 "&lt; Raw binary data. Not all messages can be encoded this way";		at: #PN_TEXT put: 1 "&lt; Raw text. Not all messages can be encoded this way";		at: #PN_AMQP put: 2 "&lt; AMQP formatted data. All messages can be encoded this way";		at: #PN_JSON put: 3 "&lt; JSON formatted data. Not all messages can be encoded with full fidelity way";		yourself.</body><body package="QpidProton">pn_status_t" Describes all the possible states for a message associated with a given tracker."	^(IdentityDictionary new)		at: #PN_STATUS_UNKNOWN put: 0 "&lt; The tracker is unknown.";		at: #PN_STATUS_PENDING put: 1 "&lt; The message is in flight. For outgoing messages, use ::pn_messenger_buffered to see if it has been sent or not.";		at: #PN_STATUS_ACCEPTED put: 2 "&lt; The message was accepted.";		at: #PN_STATUS_REJECTED put: 3 "&lt; The message was rejected.";		at: #PN_STATUS_RELEASED put: 4 "&lt; The message was released.";		at: #PN_STATUS_MODIFIED put: 5 "&lt; The message was modified.";		at: #PN_STATUS_ABORTED put: 6 "&lt; The message was aborted.";		at: #PN_STATUS_SETTLED put: 7 "&lt; The remote party has settled the message.";		yourself.</body><body package="QpidProton">pn_type_t""	^(IdentityDictionary new)		at: #PN_NULL put: 1 "";		at: #PN_BOOL put: 2 "";		at: #PN_UBYTE put: 3 "";		at: #PN_BYTE put: 4 "";		at: #PN_USHORT put: 5 "";		at: #PN_SHORT put: 6 "";		at: #PN_UINT put: 7 "";		at: #PN_INT put: 8 "";		at: #PN_CHAR put: 9 "";		at: #PN_ULONG put: 10 "";		at: #PN_LONG put: 11 "";		at: #PN_TIMESTAMP put: 12 "";		at: #PN_FLOAT put: 13 "";		at: #PN_DOUBLE put: 14 "";		at: #PN_DECIMAL32 put: 15 "";		at: #PN_DECIMAL64 put: 16 "";		at: #PN_DECIMAL128 put: 17 "";		at: #PN_UUID put: 18 "";		at: #PN_BINARY put: 19 "";		at: #PN_STRING put: 20 "";		at: #PN_SYMBOL put: 21 "";		at: #PN_DESCRIBED put: 22 "";		at: #PN_ARRAY put: 23 "";		at: #PN_LIST put: 24 "";		at: #PN_MAP put: 25 "";		yourself.</body></methods><methods><class-id>ObjectStudio.QpidProtonDLL class</class-id> <category>initialize-release</category><body package="QpidProton">initialize	QpidProtonLibrary := self new.</body></methods><methods><class-id>ObjectStudio.QpidProtonData</class-id> <category>methods</category><body package="QpidProton">append""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_append: pn_data_t "pn_data_t*"		with: pn_data_t "pn_data_t*".</body><body package="QpidProton">appendn: limit""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_appendn: pn_data_t "pn_data_t*"		with: pn_data_t "pn_data_t*"		with: limit "int".</body><body package="QpidProton">array""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_array: pn_data_t "pn_data_t*".</body><body package="QpidProton">arrayDescribed""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_is_array_described: pn_data_t "pn_data_t*".</body><body package="QpidProton">arrayType""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_array_type: pn_data_t "pn_data_t*".</body><body package="QpidProton">atom""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_atom: pn_data_t "pn_data_t*".</body><body package="QpidProton">binary""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_binary: pn_data_t "pn_data_t*".</body><body package="QpidProton">bool""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_bool: pn_data_t "pn_data_t*".</body><body package="QpidProton">byte""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_byte: pn_data_t "pn_data_t*".</body><body package="QpidProton">bytes""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_bytes: pn_data_t "pn_data_t*".</body><body package="QpidProton">char""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_char: pn_data_t "pn_data_t*".</body><body package="QpidProton">clear""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_clear: pn_data_t "pn_data_t*".</body><body package="QpidProton">copy""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_copy: pn_data_t "pn_data_t*"		with: pn_data_t "pn_data_t*".</body><body package="QpidProton">decimal128""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_decimal128: pn_data_t "pn_data_t*".</body><body package="QpidProton">decimal32""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_decimal32: pn_data_t "pn_data_t*".</body><body package="QpidProton">decimal64""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_decimal64: pn_data_t "pn_data_t*".</body><body package="QpidProton">decode: bytes size: size""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_decode: pn_data_t "pn_data_t*"		with: bytes "const char*"		with: size "size_t".</body><body package="QpidProton">described""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_is_described: pn_data_t "pn_data_t*".</body><body package="QpidProton">destroy	pn_data_t ifNil: [^self].	super destroy.	pn_data_t := nil.</body><body package="QpidProton">double""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_double: pn_data_t "pn_data_t*".</body><body package="QpidProton">encode: bytes size: size""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_encode: pn_data_t "pn_data_t*"		with: bytes "char*"		with: size "size_t".</body><body package="QpidProton">enter""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_enter: pn_data_t "pn_data_t*".</body><body package="QpidProton">errno""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_errno: pn_data_t "pn_data_t*".</body><body package="QpidProton">error""	^QpidProtonError new: (self private_error).</body><body package="QpidProton">exit""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_exit: pn_data_t "pn_data_t*".</body><body package="QpidProton">fill: fmt list: list""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_fill: pn_data_t "pn_data_t*"		with: fmt "const char*"		with: list "array".</body><body package="QpidProton">float""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_float: pn_data_t "pn_data_t*".</body><body package="QpidProton">format: bytes size: size""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_format: pn_data_t "pn_data_t*"		with: bytes "char*"		with: size "size_t*".</body><body package="QpidProton">free""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_free: pn_data_t "pn_data_t*".</body><body package="QpidProton">int""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_int: pn_data_t "pn_data_t*".</body><body package="QpidProton">list""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_list: pn_data_t "pn_data_t*".</body><body package="QpidProton">long""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_long: pn_data_t "pn_data_t*".</body><body package="QpidProton">lookup: name""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_lookup: pn_data_t "pn_data_t*"		with: name "const char*".</body><body package="QpidProton">map""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_map: pn_data_t "pn_data_t*".</body><body package="QpidProton">narrow""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_narrow: pn_data_t "pn_data_t*".</body><body package="QpidProton">next""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_next: pn_data_t "pn_data_t*".</body><body package="QpidProton">null""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_is_null: pn_data_t "pn_data_t*".</body><body package="QpidProton">pn_data_t	^pn_data_t.</body><body package="QpidProton">point""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_point: pn_data_t "pn_data_t*".</body><body package="QpidProton">prev""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_prev: pn_data_t "pn_data_t*".</body><body package="QpidProton">print""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_print: pn_data_t "pn_data_t*".</body><body package="QpidProton">private_error""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_error: pn_data_t "pn_data_t*".</body><body package="QpidProton">putArray: described type: type""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_array: pn_data_t "pn_data_t*"		with: described "bool"		with: type "pn_type_t".</body><body package="QpidProton">putAtom: atom""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_atom: pn_data_t "pn_data_t*"		with: atom "pn_atom_t".</body><body package="QpidProton">putBinary: bytes""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_binary: pn_data_t "pn_data_t*"		with: bytes "pn_bytes_t".</body><body package="QpidProton">putBool: b""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_bool: pn_data_t "pn_data_t*"		with: b "bool".</body><body package="QpidProton">putByte: b""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_byte: pn_data_t "pn_data_t*"		with: b "int8_t".</body><body package="QpidProton">putChar: c""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_char: pn_data_t "pn_data_t*"		with: c "pn_char_t".</body><body package="QpidProton">putDecimal128: d""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_decimal128: pn_data_t "pn_data_t*"		with: d "pn_decimal128_t".</body><body package="QpidProton">putDecimal32: d""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_decimal32: pn_data_t "pn_data_t*"		with: d "pn_decimal32_t".</body><body package="QpidProton">putDecimal64: d""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_decimal64: pn_data_t "pn_data_t*"		with: d "pn_decimal64_t".</body><body package="QpidProton">putDescribed""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_described: pn_data_t "pn_data_t*".</body><body package="QpidProton">putDouble: d""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_double: pn_data_t "pn_data_t*"		with: d "double".</body><body package="QpidProton">putFloat: f""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_float: pn_data_t "pn_data_t*"		with: f "float".</body><body package="QpidProton">putInt: i""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_int: pn_data_t "pn_data_t*"		with: i "int32_t".</body><body package="QpidProton">putList""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_list: pn_data_t "pn_data_t*".</body><body package="QpidProton">putLong: l""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_long: pn_data_t "pn_data_t*"		with: l "int64_t".</body><body package="QpidProton">putMap""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_map: pn_data_t "pn_data_t*".</body><body package="QpidProton">putNull""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_null: pn_data_t "pn_data_t*".</body><body package="QpidProton">putShort: s""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_short: pn_data_t "pn_data_t*"		with: s "int16_t".</body><body package="QpidProton">putString: string""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_string: pn_data_t "pn_data_t*"		with: string "pn_bytes_t".</body><body package="QpidProton">putSymbol: symbol""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_symbol: pn_data_t "pn_data_t*"		with: symbol "pn_bytes_t".</body><body package="QpidProton">putTimestamp: t""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_timestamp: pn_data_t "pn_data_t*"		with: t "pn_timestamp_t".</body><body package="QpidProton">putUbyte: ub""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_ubyte: pn_data_t "pn_data_t*"		with: ub "uint8_t".</body><body package="QpidProton">putUint: ui""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_uint: pn_data_t "pn_data_t*"		with: ui "uint32_t".</body><body package="QpidProton">putUlong: ul""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_ulong: pn_data_t "pn_data_t*"		with: ul "uint64_t".</body><body package="QpidProton">putUshort: us""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_ushort: pn_data_t "pn_data_t*"		with: us "uint16_t".</body><body package="QpidProton">putUuid: u""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_put_uuid: pn_data_t "pn_data_t*"		with: u "pn_uuid_t".</body><body package="QpidProton">restore: point""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_restore: pn_data_t "pn_data_t*"		with: point "pn_handle_t".</body><body package="QpidProton">rewind""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_rewind: pn_data_t "pn_data_t*".</body><body package="QpidProton">scan: fmt list: list""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_scan: pn_data_t "pn_data_t*"		with: fmt "const char*"		with: list "array".</body><body package="QpidProton">short""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_short: pn_data_t "pn_data_t*".</body><body package="QpidProton">size""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_size: pn_data_t "pn_data_t*".</body><body package="QpidProton">string""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_string: pn_data_t "pn_data_t*".</body><body package="QpidProton">symbol""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_symbol: pn_data_t "pn_data_t*".</body><body package="QpidProton">timestamp""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_timestamp: pn_data_t "pn_data_t*".</body><body package="QpidProton">type""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_type: pn_data_t "pn_data_t*".</body><body package="QpidProton">ubyte""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_ubyte: pn_data_t "pn_data_t*".</body><body package="QpidProton">uint""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_uint: pn_data_t "pn_data_t*".</body><body package="QpidProton">ulong""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_ulong: pn_data_t "pn_data_t*".</body><body package="QpidProton">ushort""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_ushort: pn_data_t "pn_data_t*".</body><body package="QpidProton">uuid""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_get_uuid: pn_data_t "pn_data_t*".</body><body package="QpidProton">vfill: fmt ap: ap""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_vfill: pn_data_t "pn_data_t*"		with: fmt "const char*"		with: ap "va_list".</body><body package="QpidProton">vscan: fmt ap: ap""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_vscan: pn_data_t "pn_data_t*"		with: fmt "const char*"		with: ap "va_list".</body><body package="QpidProton">widen""	pn_data_t ifNil: [^nil].	^QpidProtonLibrary 		pn_data_widen: pn_data_t "pn_data_t*".</body></methods><methods><class-id>ObjectStudio.QpidProtonData class</class-id> <category>methods</category><body package="QpidProton">new: pn_data_t	| obj |	obj := super new.	obj varAt: #pn_data_t put: pn_data_t.	^obj.</body><body package="QpidProton">newCapacity: capacity""	^self new: (QpidProtonLibrary 		pn_data: capacity "size_t").</body></methods><methods><class-id>ObjectStudio.QpidProtonMessage</class-id> <category>methods</category><body package="QpidProton">address" Get the address for a message. This operation will return NULL if no address has been set or if the address has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_address() @param[in] msg a message object @return a pointer to the address of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_address: pn_message_t "pn_message_t*".</body><body package="QpidProton">address: address" Set the address for a message. The supplied address pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the address of the message is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] address a pointer to the new address (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_address: pn_message_t "pn_message_t*"		with: address "const char*".</body><body package="QpidProton">annotations" Get/set the annotations for a message. This operation returns a pointer to a ::pn_data_t representing the content of the annotations section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the annotations section of a message. The ::pn_data_t must either be empty or consist of a symbol keyed map in order to be considered valid message annotations. @param[in] msg a message object @return a pointer to the message annotations"	^QpidProtonData new: (self private_annotations).</body><body package="QpidProton">body" Get/set the body of a message. This operation returns a pointer to a ::pn_data_t representing the body of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the message body. @param[in] msg a message object @return a pointer to the message body"	^QpidProtonData new: (self private_body).</body><body package="QpidProton">clear" Clears the content of a ::pn_message_t. When pn_message_clear returns, the supplied ::pn_message_t will be emptied of all content and effectively returned to the same state as if it was just created. @param[in] msg pointer to the ::pn_message_t to be cleared"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_clear: pn_message_t "pn_message_t*".</body><body package="QpidProton">contentEncoding" Get the content_encoding for a message. This operation will return NULL if no content_encoding has been set or if the content_encoding has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_content_encoding() @param[in] msg a message object @return a pointer to the content_encoding of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_content_encoding: pn_message_t "pn_message_t*".</body><body package="QpidProton">contentEncoding: encoding" Set the content_encoding for a message. The supplied content_encoding pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the content_encoding is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] encoding a pointer to the new content_encoding (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_content_encoding: pn_message_t "pn_message_t*"		with: encoding "const char*".</body><body package="QpidProton">contentType" Get the content_type for a message. This operation will return NULL if no content_type has been set or if the content_type has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_content_type() @param[in] msg a message object @return a pointer to the content_type of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_content_type: pn_message_t "pn_message_t*".</body><body package="QpidProton">contentType: type" Set the content_type for a message. The supplied content_type pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the content_type is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] type a pointer to the new content_type (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_content_type: pn_message_t "pn_message_t*"		with: type "const char*".</body><body package="QpidProton">correlationId" Get the correlation id for a message. A correlation id can be an a string, an unsigned long, a uuid or a binary value. This operation returns the value of the id using the ::pn_atom_t descriminated union. See ::pn_atom_t for details on how to access the value. @param[in] msg a message object @return the message id"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_correlation_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">correlationId: id" Set the correlation id for a message. See ::pn_message_get_correlation_id() for more details on the meaning of the correlation id. Note that only string, unsigned long, uuid, or binary values are permitted. @param[in] msg a message object @param[in] id the new value of the message id @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_correlation_id: pn_message_t "pn_message_t*"		with: id "pn_atom_t".</body><body package="QpidProton">creationTime" Get the creation time for a message. A zero value for the creation time indicates that the creation time has not been set. This is the default value. @param[in] msg a message object @return the creation time for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_creation_time: pn_message_t "pn_message_t*".</body><body package="QpidProton">creationTime: time" Set the creation time for a message. See ::pn_message_get_creation_time() for more details. @param[in] msg a message object @param[in] time the new creation time for the message @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_creation_time: pn_message_t "pn_message_t*"		with: time "pn_timestamp_t".</body><body package="QpidProton">data: dst available: available src: src size: size" @deprecated"	^QpidProtonLibrary 		pn_message_data: dst "char*"		with: available "size_t"		with: src "const char*"		with: size "size_t".</body><body package="QpidProton">decode: bytes size: size" Decode/load message content from AMQP formatted binary data. Upon invoking this operation, any existing message content will be cleared and replaced with the content from the provided binary data. @param[in] msg a message object @param[in] bytes the start of the encoded AMQP data @param[in] size the size of the encoded AMQP data @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_decode: pn_message_t "pn_message_t*"		with: bytes "const char*"		with: size "size_t".</body><body package="QpidProton">deliveryCount" Get the delivery count for a message. The delivery count field tracks how many attempts have been made to delivery a message. Use ::pn_message_set_delivery_count() to set the delivery count for a message. @param[in] msg a message object @return the delivery count for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_delivery_count: pn_message_t "pn_message_t*".</body><body package="QpidProton">deliveryCount: count" Set the delivery count for a message. See ::pn_message_get_delivery_count() for details on what the delivery count means. @param[in] msg a message object @param[in] count the new delivery count @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_delivery_count: pn_message_t "pn_message_t*"		with: count "uint32_t".</body><body package="QpidProton">destroy	pn_message_t ifNil: [^self].	super destroy.	pn_message_t := nil.</body><body package="QpidProton">durable" Get the durable flag for a message. The durable flag indicates that any parties taking responsibility for the message must durably store the content. @param[in] msg a message object @return the value of the durable flag"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_is_durable: pn_message_t "pn_message_t*".</body><body package="QpidProton">durable: durable" Set the durable flag for a message. See ::pn_message_is_durable() for a description of the durable flag. @param[in] msg a message object @param[in] durable the new value of the durable flag @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_durable: pn_message_t "pn_message_t*"		with: durable "bool".</body><body package="QpidProton">encode: bytes size: size" Encode/save message content as AMQP formatted binary data. If the buffer space provided is insufficient to store the content held in the message, the operation will fail and return a ::PN_OVERFLOW error code. @param[in] msg a message object @param[in] bytes the start of empty buffer space @param[in] size the amount of empty buffer space @param[out] size the amount of data written @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_encode: pn_message_t "pn_message_t*"		with: bytes "char*"		with: size "size_t*".</body><body package="QpidProton">errno" Access the error code of a message. Every operation on a message that can result in an error will set the message's error code in case of error. The pn_message_errno() call will access the error code of the most recent failed operation. @param[in] msg a message @return the message's error code"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_errno: pn_message_t "pn_message_t*".</body><body package="QpidProton">error" Access the error information for a message. Every operation on a message that can result in an error will update the error information held by its error descriptor should that operation fail. The pn_message_error() call will access the error information of the most recent failed operation. The pointer returned by this call is valid until the message is freed. @param[in] msg a message @return the message's error descriptor"	^QpidProtonError new: (self private_error).</body><body package="QpidProton">expiryTime" Get the expiry time for a message. A zero value for the expiry time indicates that the message will never expire. This is the default value. @param[in] msg a message object @return the expiry time for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_expiry_time: pn_message_t "pn_message_t*".</body><body package="QpidProton">expiryTime: time" Set the expiry time for a message. See ::pn_message_get_expiry_time() for more details. @param[in] msg a message object @param[in] time the new expiry time for the message @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_expiry_time: pn_message_t "pn_message_t*"		with: time "pn_timestamp_t".</body><body package="QpidProton">firstAcquirer" Get the first acquirer flag for a message. When set to true, the first acquirer flag for a message indicates that the recipient of the message is the first recipient to acquire the message, i.e. there have been no failed delivery attempts to other acquirers. Note that this does not mean the message has not been delivered to, but not acquired, by other recipients. @param[in] msg a message object @return the first acquirer flag for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_is_first_acquirer: pn_message_t "pn_message_t*".</body><body package="QpidProton">firstAcquirer: first" Set the first acquirer flag for a message. See ::pn_message_is_first_acquirer() for details on the first acquirer flag. @param[in] msg a message object @param[in] first the new value for the first acquirer flag @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_first_acquirer: pn_message_t "pn_message_t*"		with: first "bool".</body><body package="QpidProton">format" @deprecated"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_format: pn_message_t "pn_message_t*".</body><body package="QpidProton">format: format" @deprecated"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_format: pn_message_t "pn_message_t*"		with: format "pn_format_t".</body><body package="QpidProton">free" Free a previously constructed ::pn_message_t. @param[in] msg pointer to a ::pn_message_t or NULL"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_free: pn_message_t "pn_message_t*".</body><body package="QpidProton">getID" Get/set the id for a message. The message id provides a globally unique identifier for a message. A message id can be an a string, an unsigned long, a uuid or a binary value. This operation returns a pointer to a ::pn_data_t that can be used to access and/or modify the value of the message id. The pointer is valid until the message is freed. See ::pn_data_t for details on how to get/set the value. @param[in] msg a message object @return pointer to a ::pn_data_t holding the id"	^QpidProtonData new: (self private_getID).</body><body package="QpidProton">groupId" Get the group_id for a message. This operation will return NULL if no group_id has been set or if the group_id has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_group_id() @param[in] msg a message object @return a pointer to the group_id of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_group_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">groupId: group_id" Set the group_id for a message. The supplied group_id pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the group_id is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] group_id a pointer to the new group_id (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_group_id: pn_message_t "pn_message_t*"		with: group_id "const char*".</body><body package="QpidProton">groupSequence" Get the group sequence for a message. The group sequence of a message identifies the relative ordering of messages within a group. The default value for the group sequence of a message is zero. @param[in] msg a message object @return the group sequence for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_group_sequence: pn_message_t "pn_message_t*".</body><body package="QpidProton">groupSequence: n" Set the group sequence for a message. See ::pn_message_get_group_sequence() for details on what the group sequence means. @param[in] msg a message object @param[in] n the new group sequence for the message @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_group_sequence: pn_message_t "pn_message_t*"		with: n "pn_sequence_t".</body><body package="QpidProton">id" Get the id for a message. The message id provides a globally unique identifier for a message. A message id can be an a string, an unsigned long, a uuid or a binary value. This operation returns the value of the id using the ::pn_atom_t descriminated union. See ::pn_atom_t for details on how to access the value. @param[in] msg a message object @return the message id"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">id: id" Set the id for a message. See ::pn_message_get_id() for more details on the meaning of the message id. Note that only string, unsigned long, uuid, or binary values are permitted. @param[in] msg a message object @param[in] id the new value of the message id @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_id: pn_message_t "pn_message_t*"		with: id "pn_atom_t".</body><body package="QpidProton">inferred" Get the inferred flag for a message. The inferred flag for a message indicates how the message content is encoded into AMQP sections. If inferred is true then binary and list values in the body of the message will be encoded as AMQP DATA and AMQP SEQUENCE sections, respectively. If inferred is false, then all values in the body of the message will be encoded as AMQP VALUE sections regardless of their type. Use ::pn_message_set_inferred to set the value. @param[in] msg a message object @return the value of the inferred flag for the message"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_is_inferred: pn_message_t "pn_message_t*".</body><body package="QpidProton">inferred: inferred" Set the inferred flag for a message. See ::pn_message_is_inferred() for a description of what the inferred flag is. @param[in] msg a message object @param[in] inferred the new value of the inferred flag @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_inferred: pn_message_t "pn_message_t*"		with: inferred "bool".</body><body package="QpidProton">instructions" Get/set the delivery instructions for a message. This operation returns a pointer to a ::pn_data_t representing the content of the delivery instructions section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the delivery instructions section of a message. The ::pn_data_t must either be empty or consist of a symbol keyed map in order to be considered valid delivery instructions. @param[in] msg a message object @return a pointer to the delivery instructions"	^QpidProtonData new: (self private_instructions).</body><body package="QpidProton">load: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_load: pn_message_t "pn_message_t*"		with: data "const char*"		with: size "size_t".</body><body package="QpidProton">loadAmqp: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_load_amqp: pn_message_t "pn_message_t*"		with: data "const char*"		with: size "size_t".</body><body package="QpidProton">loadData: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_load_data: pn_message_t "pn_message_t*"		with: data "const char*"		with: size "size_t".</body><body package="QpidProton">loadJson: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_load_json: pn_message_t "pn_message_t*"		with: data "const char*"		with: size "size_t".</body><body package="QpidProton">loadText: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_load_text: pn_message_t "pn_message_t*"		with: data "const char*"		with: size "size_t".</body><body package="QpidProton">pn_message_t	^pn_message_t.</body><body package="QpidProton">priority" Get the priority for a message. The priority of a message impacts ordering guarantees. Within a given ordered context, higher priority messages may jump ahead of lower priority messages. @param[in] msg a message object @return the message priority"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_priority: pn_message_t "pn_message_t*".</body><body package="QpidProton">priority: priority" Set the priority for a message. See ::pn_message_get_priority() for details on message priority. @param[in] msg a message object @param[in] priority the new priority for the message @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_priority: pn_message_t "pn_message_t*"		with: priority "uint8_t".</body><body package="QpidProton">private_annotations" Get/set the annotations for a message. This operation returns a pointer to a ::pn_data_t representing the content of the annotations section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the annotations section of a message. The ::pn_data_t must either be empty or consist of a symbol keyed map in order to be considered valid message annotations. @param[in] msg a message object @return a pointer to the message annotations"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_annotations: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_body" Get/set the body of a message. This operation returns a pointer to a ::pn_data_t representing the body of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the message body. @param[in] msg a message object @return a pointer to the message body"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_body: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_correlationId" Get/set the correlation id for a message. A correlation id can be an a string, an unsigned long, a uuid or a binary value. This operation returns a pointer to a ::pn_data_t that can be used to access and/or modify the value of the correlation id. The pointer is valid until the message is freed. See ::pn_data_t for details on how to get/set the value. @param[in] msg a message object @return pointer to a ::pn_data_t holding the correlation id"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_correlation_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_error" Access the error information for a message. Every operation on a message that can result in an error will update the error information held by its error descriptor should that operation fail. The pn_message_error() call will access the error information of the most recent failed operation. The pointer returned by this call is valid until the message is freed. @param[in] msg a message @return the message's error descriptor"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_error: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_getID" Get/set the id for a message. The message id provides a globally unique identifier for a message. A message id can be an a string, an unsigned long, a uuid or a binary value. This operation returns a pointer to a ::pn_data_t that can be used to access and/or modify the value of the message id. The pointer is valid until the message is freed. See ::pn_data_t for details on how to get/set the value. @param[in] msg a message object @return pointer to a ::pn_data_t holding the id"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_instructions" Get/set the delivery instructions for a message. This operation returns a pointer to a ::pn_data_t representing the content of the delivery instructions section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the delivery instructions section of a message. The ::pn_data_t must either be empty or consist of a symbol keyed map in order to be considered valid delivery instructions. @param[in] msg a message object @return a pointer to the delivery instructions"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_instructions: pn_message_t "pn_message_t*".</body><body package="QpidProton">private_properties" Get/set the properties for a message. This operation returns a pointer to a ::pn_data_t representing the content of the properties section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the properties section of a message. The ::pn_data_t must either be empty or consist of a string keyed map in order to be considered valid message properties. @param[in] msg a message object @return a pointer to the message properties"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_properties: pn_message_t "pn_message_t*".</body><body package="QpidProton">properties" Get/set the properties for a message. This operation returns a pointer to a ::pn_data_t representing the content of the properties section of a message. The pointer is valid until the message is freed and may be used to both access and modify the content of the properties section of a message. The ::pn_data_t must either be empty or consist of a string keyed map in order to be considered valid message properties. @param[in] msg a message object @return a pointer to the message properties"	^QpidProtonData new: (self private_properties).</body><body package="QpidProton">replyTo" Get the reply_to for a message. This operation will return NULL if no reply_to has been set or if the reply_to has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_reply_to() @param[in] msg a message object @return a pointer to the reply_to of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_reply_to: pn_message_t "pn_message_t*".</body><body package="QpidProton">replyTo: reply_to" Set the reply_to for a message. The supplied reply_to pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the reply_to is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] reply_to a pointer to the new reply_to (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_reply_to: pn_message_t "pn_message_t*"		with: reply_to "const char*".</body><body package="QpidProton">replyToGroupId" Get the reply_to_group_id for a message. This operation will return NULL if no reply_to_group_id has been set or if the reply_to_group_id has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_reply_to_group_id() @param[in] msg a message object @return a pointer to the reply_to_group_id of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_reply_to_group_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">replyToGroupId: reply_to_group_id" Set the reply_to_group_id for a message. The supplied reply_to_group_id pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the reply_to_group_id is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] reply_to_group_id a pointer to the new reply_to_group_id (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_reply_to_group_id: pn_message_t "pn_message_t*"		with: reply_to_group_id "const char*".</body><body package="QpidProton">save: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_save: pn_message_t "pn_message_t*"		with: data "char*"		with: size "size_t*".</body><body package="QpidProton">saveAmqp: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_save_amqp: pn_message_t "pn_message_t*"		with: data "char*"		with: size "size_t*".</body><body package="QpidProton">saveData: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_save_data: pn_message_t "pn_message_t*"		with: data "char*"		with: size "size_t*".</body><body package="QpidProton">saveJson: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_save_json: pn_message_t "pn_message_t*"		with: data "char*"		with: size "size_t*".</body><body package="QpidProton">saveText: data size: size" @deprecated Use ::pn_message_body() instead."	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_save_text: pn_message_t "pn_message_t*"		with: data "char*"		with: size "size_t*".</body><body package="QpidProton">subject" Get the subject for a message. This operation will return NULL if no subject has been set or if the subject has been set to NULL. The pointer returned by this operation is valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_subject() @param[in] msg a message object @return a pointer to the subject of the message (or NULL)"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_subject: pn_message_t "pn_message_t*".</body><body package="QpidProton">subject: subject" Set the subject for a message. The supplied subject pointer must either be NULL or reference a NUL terminated string. When the pointer is NULL, the subject is set to NULL. When the pointer is non NULL, the contents are copied into the message. @param[in] msg a message object @param[in] subject a pointer to the new subject (or NULL) @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_subject: pn_message_t "pn_message_t*"		with: subject "const char*".</body><body package="QpidProton">ttl" Get the ttl for a message. The ttl for a message determines how long a message is considered live. When a message is held for retransmit, the ttl is decremented. Once the ttl reaches zero, the message is considered dead. Once a message is considered dead it may be dropped. Use ::pn_message_set_ttl() to set the ttl for a message. @param[in] msg a message object @return the ttl in milliseconds"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_ttl: pn_message_t "pn_message_t*".</body><body package="QpidProton">ttl: ttl" Set the ttl for a message. See ::pn_message_get_ttl() for a detailed description of message ttl. @param[in] msg a message object @param[in] ttl the new value for the message ttl @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_ttl: pn_message_t "pn_message_t*"		with: ttl "pn_millis_t".</body><body package="QpidProton">userId" Get the user id for a message. The pointer referenced by the ::pn_bytes_t struct will be valid until any one of the following operations occur:  - ::pn_message_free()  - ::pn_message_clear()  - ::pn_message_set_user_id() @param[in] msg a message object @return a pn_bytes_t referencing the message's user_id"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_get_user_id: pn_message_t "pn_message_t*".</body><body package="QpidProton">userId: user_id" Set the user id for a message. This operation copies the bytes referenced by the provided ::pn_bytes_t struct. @param[in] msg a message object @param[in] user_id the new user_id for the message @return zero on success or an error code on failure"	pn_message_t ifNil: [^nil].	^QpidProtonLibrary 		pn_message_set_user_id: pn_message_t "pn_message_t*"		with: user_id "pn_bytes_t".</body></methods><methods><class-id>ObjectStudio.QpidProtonMessage class</class-id> <category>methods</category><body package="QpidProton">new" Construct a new ::pn_message_t. Every message that is constructed must be freed using ::pn_message_free(). @return pointer to a new ::pn_message_t"	^self new: (QpidProtonLibrary 		pn_message).</body><body package="QpidProton">new: pn_message_t	| obj |	obj := super new.	obj varAt: #pn_message_t put: pn_message_t.	^obj.</body></methods><methods><class-id>ObjectStudio.QpidProtonDLL</class-id> <category>procedures</category><body package="QpidProton">pn_bytes: size with: start 	&lt;C:  pn_bytes_t pn_bytes(size_t size, const char *start)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_code: code 	&lt;C:  const char *pn_code(int code)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data: capacity 	&lt;C:  pn_data_t *pn_data(size_t capacity)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_append: data with: src 	&lt;C:  int pn_data_append(pn_data_t *data, pn_data_t *src)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_appendn: data with: src with: limit 	&lt;C:  int pn_data_appendn(pn_data_t *data, pn_data_t *src, int limit)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_clear: data 	&lt;C:  void pn_data_clear(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_copy: data with: src 	&lt;C:  int pn_data_copy(pn_data_t *data, pn_data_t *src)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_decode: data with: bytes with: size 	&lt;C:  ssize_t pn_data_decode(pn_data_t *data, const char *bytes, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_encode: data with: bytes with: size 	&lt;C:  ssize_t pn_data_encode(pn_data_t *data, char *bytes, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_enter: data 	&lt;C:  bool pn_data_enter(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_errno: data 	&lt;C:  int pn_data_errno(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_error: data 	&lt;C:  pn_error_t *pn_data_error(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_exit: data 	&lt;C:  bool pn_data_exit(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_fill: data with: fmt with: list 	&lt;C:  int pn_data_fill(pn_data_t *data, const char *fmt, const char * list)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_format: data with: bytes with: size 	&lt;C:  int pn_data_format(pn_data_t *data, char *bytes, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_free: data 	&lt;C:  void pn_data_free(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_array: data 	&lt;C:  size_t pn_data_get_array(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_array_type: data 	&lt;C:  pn_type_t pn_data_get_array_type(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_atom: data 	&lt;C:  pn_atom_t pn_data_get_atom(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_binary: data 	&lt;C:  pn_bytes_t pn_data_get_binary(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_bool: data 	&lt;C:  bool pn_data_get_bool(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_byte: data 	&lt;C:  int8_t pn_data_get_byte(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_bytes: data 	&lt;C:  pn_bytes_t pn_data_get_bytes(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_char: data 	&lt;C:  pn_char_t pn_data_get_char(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_decimal128: data 	&lt;C:  pn_decimal128_t pn_data_get_decimal128(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_decimal32: data 	&lt;C:  pn_decimal32_t pn_data_get_decimal32(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_decimal64: data 	&lt;C:  pn_decimal64_t pn_data_get_decimal64(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_double: data 	&lt;C:  double pn_data_get_double(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_float: data 	&lt;C:  float pn_data_get_float(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_int: data 	&lt;C:  int32_t pn_data_get_int(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_list: data 	&lt;C:  size_t pn_data_get_list(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_long: data 	&lt;C:  int64_t pn_data_get_long(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_map: data 	&lt;C:  size_t pn_data_get_map(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_short: data 	&lt;C:  int16_t pn_data_get_short(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_string: data 	&lt;C:  pn_bytes_t pn_data_get_string(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_symbol: data 	&lt;C:  pn_bytes_t pn_data_get_symbol(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_timestamp: data 	&lt;C:  pn_timestamp_t pn_data_get_timestamp(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_ubyte: data 	&lt;C:  uint8_t pn_data_get_ubyte(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_uint: data 	&lt;C:  uint32_t pn_data_get_uint(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_ulong: data 	&lt;C:  uint64_t pn_data_get_ulong(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_ushort: data 	&lt;C:  uint16_t pn_data_get_ushort(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_get_uuid: data 	&lt;C:  pn_uuid_t pn_data_get_uuid(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_is_array_described: data 	&lt;C:  bool pn_data_is_array_described(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_is_described: data 	&lt;C:  bool pn_data_is_described(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_is_null: data 	&lt;C:  bool pn_data_is_null(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_lookup: data with: name 	&lt;C:  bool pn_data_lookup(pn_data_t *data, const char *name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_narrow: data 	&lt;C:  void pn_data_narrow(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_next: data 	&lt;C:  bool pn_data_next(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_point: data 	&lt;C:  pn_handle_t pn_data_point(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_prev: data 	&lt;C:  bool pn_data_prev(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_print: data 	&lt;C:  int pn_data_print(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_array: data with: described with: type 	&lt;C:  int pn_data_put_array(pn_data_t *data, bool described, pn_type_t type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_atom: data with: atom 	&lt;C:  int pn_data_put_atom(pn_data_t *data, pn_atom_t atom)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_binary: data with: bytes 	&lt;C:  int pn_data_put_binary(pn_data_t *data, pn_bytes_t bytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_bool: data with: b 	&lt;C:  int pn_data_put_bool(pn_data_t *data, bool b)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_byte: data with: b 	&lt;C:  int pn_data_put_byte(pn_data_t *data, int8_t b)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_char: data with: c 	&lt;C:  int pn_data_put_char(pn_data_t *data, pn_char_t c)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_decimal128: data with: d 	&lt;C:  int pn_data_put_decimal128(pn_data_t *data, pn_decimal128_t d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_decimal32: data with: d 	&lt;C:  int pn_data_put_decimal32(pn_data_t *data, pn_decimal32_t d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_decimal64: data with: d 	&lt;C:  int pn_data_put_decimal64(pn_data_t *data, pn_decimal64_t d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_described: data 	&lt;C:  int pn_data_put_described(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_double: data with: d 	&lt;C:  int pn_data_put_double(pn_data_t *data, double d)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_float: data with: f 	&lt;C:  int pn_data_put_float(pn_data_t *data, float f)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_int: data with: i 	&lt;C:  int pn_data_put_int(pn_data_t *data, int32_t i)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_list: data 	&lt;C:  int pn_data_put_list(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_long: data with: l 	&lt;C:  int pn_data_put_long(pn_data_t *data, int64_t l)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_map: data 	&lt;C:  int pn_data_put_map(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_null: data 	&lt;C:  int pn_data_put_null(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_short: data with: s 	&lt;C:  int pn_data_put_short(pn_data_t *data, int16_t s)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_string: data with: string 	&lt;C:  int pn_data_put_string(pn_data_t *data, pn_bytes_t string)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_symbol: data with: symbol 	&lt;C:  int pn_data_put_symbol(pn_data_t *data, pn_bytes_t symbol)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_timestamp: data with: t 	&lt;C:  int pn_data_put_timestamp(pn_data_t *data, pn_timestamp_t t)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_ubyte: data with: ub 	&lt;C:  int pn_data_put_ubyte(pn_data_t *data, uint8_t ub)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_uint: data with: ui 	&lt;C:  int pn_data_put_uint(pn_data_t *data, uint32_t ui)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_ulong: data with: ul 	&lt;C:  int pn_data_put_ulong(pn_data_t *data, uint64_t ul)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_ushort: data with: us 	&lt;C:  int pn_data_put_ushort(pn_data_t *data, uint16_t us)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_put_uuid: data with: u 	&lt;C:  int pn_data_put_uuid(pn_data_t *data, pn_uuid_t u)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_restore: data with: point 	&lt;C:  bool pn_data_restore(pn_data_t *data, pn_handle_t point)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_rewind: data 	&lt;C:  void pn_data_rewind(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_scan: data with: fmt with: list 	&lt;C:  int pn_data_scan(pn_data_t *data, const char *fmt, const char * list)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_size: data 	&lt;C:  size_t pn_data_size(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_type: data 	&lt;C:  pn_type_t pn_data_type(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_vfill: data with: fmt with: ap 	&lt;C:  int pn_data_vfill(pn_data_t *data, const char *fmt, va_list ap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_vscan: data with: fmt with: ap 	&lt;C:  int pn_data_vscan(pn_data_t *data, const char *fmt, va_list ap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_data_widen: data 	&lt;C:  void pn_data_widen(pn_data_t *data)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error	&lt;C:  pn_error_t *pn_error(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_clear: error 	&lt;C:  void pn_error_clear(pn_error_t *error)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_code: error 	&lt;C:  int pn_error_code(pn_error_t *error)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_copy: error with: src 	&lt;C:  int pn_error_copy(pn_error_t *error, pn_error_t *src)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_format: error with: code with: fmt with: list 	&lt;C:  int pn_error_format(pn_error_t *error, int code, const char *fmt, const char * list)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_free: error 	&lt;C:  void pn_error_free(pn_error_t *error)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_set: error with: code with: text 	&lt;C:  int pn_error_set(pn_error_t *error, int code, const char *text)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_text: error 	&lt;C:  const char *pn_error_text(pn_error_t *error)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_error_vformat: error with: code with: fmt with: ap 	&lt;C:  int pn_error_vformat(pn_error_t *error, int code, const char *fmt, va_list ap)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message	&lt;C:  pn_message_t * pn_message(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_annotations: msg 	&lt;C:  pn_data_t *pn_message_annotations(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_body: msg 	&lt;C:  pn_data_t *pn_message_body(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_clear: msg 	&lt;C:  void           pn_message_clear(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_correlation_id: msg 	&lt;C:  pn_data_t *    pn_message_correlation_id        (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_data: dst with: available with: src with: size 	&lt;C:  ssize_t pn_message_data(char *dst, size_t available, const char *src, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_decode: msg with: bytes with: size 	&lt;C:  int pn_message_decode(pn_message_t *msg, const char *bytes, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_encode: msg with: bytes with: size 	&lt;C:  int pn_message_encode(pn_message_t *msg, char *bytes, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_errno: msg 	&lt;C:  int            pn_message_errno(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_error: msg 	&lt;C:  pn_error_t    *pn_message_error(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_free: msg 	&lt;C:  void           pn_message_free(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_address: msg 	&lt;C:  const char *   pn_message_get_address           (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_content_encoding: msg 	&lt;C:  const char *   pn_message_get_content_encoding  (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_content_type: msg 	&lt;C:  const char *   pn_message_get_content_type      (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_correlation_id: msg 	&lt;C:  pn_atom_t      pn_message_get_correlation_id    (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_creation_time: msg 	&lt;C:  pn_timestamp_t pn_message_get_creation_time     (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_delivery_count: msg 	&lt;C:  uint32_t       pn_message_get_delivery_count    (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_expiry_time: msg 	&lt;C:  pn_timestamp_t pn_message_get_expiry_time       (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_format: message 	&lt;C:  pn_format_t pn_message_get_format(pn_message_t *message)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_group_id: msg 	&lt;C:  const char *   pn_message_get_group_id          (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_group_sequence: msg 	&lt;C:  pn_sequence_t  pn_message_get_group_sequence    (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_id: msg 	&lt;C:  pn_atom_t      pn_message_get_id                (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_priority: msg 	&lt;C:  uint8_t        pn_message_get_priority          (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_reply_to: msg 	&lt;C:  const char *   pn_message_get_reply_to          (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_reply_to_group_id: msg 	&lt;C:  const char *   pn_message_get_reply_to_group_id (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_subject: msg 	&lt;C:  const char *   pn_message_get_subject           (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_ttl: msg 	&lt;C:  pn_millis_t    pn_message_get_ttl               (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_get_user_id: msg 	&lt;C:  pn_bytes_t     pn_message_get_user_id           (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_id: msg 	&lt;C:  pn_data_t *    pn_message_id                    (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_instructions: msg 	&lt;C:  pn_data_t *pn_message_instructions(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_is_durable: msg 	&lt;C:  bool           pn_message_is_durable            (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_is_first_acquirer: msg 	&lt;C:  bool           pn_message_is_first_acquirer     (pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_is_inferred: msg 	&lt;C:  bool           pn_message_is_inferred(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_load: message with: data with: size 	&lt;C:  int pn_message_load(pn_message_t *message, const char *data, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_load_amqp: message with: data with: size 	&lt;C:  int pn_message_load_amqp(pn_message_t *message, const char *data, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_load_data: message with: data with: size 	&lt;C:  int pn_message_load_data(pn_message_t *message, const char *data, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_load_json: message with: data with: size 	&lt;C:  int pn_message_load_json(pn_message_t *message, const char *data, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_load_text: message with: data with: size 	&lt;C:  int pn_message_load_text(pn_message_t *message, const char *data, size_t size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_properties: msg 	&lt;C:  pn_data_t *pn_message_properties(pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_save: message with: data with: size 	&lt;C:  int pn_message_save(pn_message_t *message, char *data, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_save_amqp: message with: data with: size 	&lt;C:  int pn_message_save_amqp(pn_message_t *message, char *data, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_save_data: message with: data with: size 	&lt;C:  int pn_message_save_data(pn_message_t *message, char *data, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_save_json: message with: data with: size 	&lt;C:  int pn_message_save_json(pn_message_t *message, char *data, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_save_text: message with: data with: size 	&lt;C:  int pn_message_save_text(pn_message_t *message, char *data, size_t *size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_address: msg with: address 	&lt;C:  int            pn_message_set_address           (pn_message_t *msg, const char *address)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_content_encoding: msg with: encoding 	&lt;C:  int            pn_message_set_content_encoding  (pn_message_t *msg, const char *encoding)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_content_type: msg with: type 	&lt;C:  int            pn_message_set_content_type      (pn_message_t *msg, const char *type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_correlation_id: msg with: id 	&lt;C:  int            pn_message_set_correlation_id    (pn_message_t *msg, pn_atom_t id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_creation_time: msg with: time 	&lt;C:  int            pn_message_set_creation_time     (pn_message_t *msg, pn_timestamp_t time)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_delivery_count: msg with: count 	&lt;C:  int            pn_message_set_delivery_count    (pn_message_t *msg, uint32_t count)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_durable: msg with: durable 	&lt;C:  int            pn_message_set_durable           (pn_message_t *msg, bool durable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_expiry_time: msg with: time 	&lt;C:  int            pn_message_set_expiry_time       (pn_message_t *msg, pn_timestamp_t time)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_first_acquirer: msg with: first 	&lt;C:  int            pn_message_set_first_acquirer    (pn_message_t *msg, bool first)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_format: message with: format 	&lt;C:  int pn_message_set_format(pn_message_t *message, pn_format_t format)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_group_id: msg with: group_id 	&lt;C:  int            pn_message_set_group_id          (pn_message_t *msg, const char *group_id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_group_sequence: msg with: n 	&lt;C:  int            pn_message_set_group_sequence    (pn_message_t *msg, pn_sequence_t n)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_id: msg with: id 	&lt;C:  int            pn_message_set_id                (pn_message_t *msg, pn_atom_t id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_inferred: msg with: inferred 	&lt;C:  int            pn_message_set_inferred(pn_message_t *msg, bool inferred)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_priority: msg with: priority 	&lt;C:  int            pn_message_set_priority          (pn_message_t *msg, uint8_t priority)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_reply_to: msg with: reply_to 	&lt;C:  int            pn_message_set_reply_to          (pn_message_t *msg, const char *reply_to)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_reply_to_group_id: msg with: reply_to_group_id 	&lt;C:  int            pn_message_set_reply_to_group_id (pn_message_t *msg, const char *reply_to_group_id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_subject: msg with: subject 	&lt;C:  int            pn_message_set_subject           (pn_message_t *msg, const char *subject)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_ttl: msg with: ttl 	&lt;C:  int            pn_message_set_ttl               (pn_message_t *msg, pn_millis_t ttl)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_message_set_user_id: msg with: user_id 	&lt;C:  int            pn_message_set_user_id           (pn_message_t *msg, pn_bytes_t user_id)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger: name 	&lt;C:  pn_messenger_t *pn_messenger(const char *name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_accept: messenger with: tracker with: flags 	&lt;C:  int pn_messenger_accept(pn_messenger_t *messenger, pn_tracker_t tracker, int flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_buffered: messenger with: tracker 	&lt;C:  bool pn_messenger_buffered(pn_messenger_t *messenger, pn_tracker_t tracker)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_deadline: messenger 	&lt;C:  pn_timestamp_t pn_messenger_deadline(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_delivery: messenger with: tracker 	&lt;C:  pn_delivery_t *pn_messenger_delivery(pn_messenger_t *messenger, pn_tracker_t tracker)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_errno: messenger 	&lt;C:  int pn_messenger_errno(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_error: messenger 	&lt;C:  pn_error_t *pn_messenger_error(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_free: messenger 	&lt;C:  void pn_messenger_free(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get: messenger with: message 	&lt;C:  int pn_messenger_get(pn_messenger_t *messenger, pn_message_t *message)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_certificate: messenger 	&lt;C:  const char *pn_messenger_get_certificate(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_flags: messenger 	&lt;C:  int pn_messenger_get_flags(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_incoming_window: messenger 	&lt;C:  int pn_messenger_get_incoming_window(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_link: messenger with: address with: sender 	&lt;C:  pn_link_t *pn_messenger_get_link(pn_messenger_t *messenger, const char *address, bool sender)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_outgoing_window: messenger 	&lt;C:  int pn_messenger_get_outgoing_window(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_password: messenger 	&lt;C:  const char *pn_messenger_get_password(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_private_key: messenger 	&lt;C:  const char *pn_messenger_get_private_key(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_remote_idle_timeout: messenger with: address 	&lt;C:  pn_millis_t pn_messenger_get_remote_idle_timeout(pn_messenger_t *messenger, const char *address)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_timeout: messenger 	&lt;C:  int pn_messenger_get_timeout(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_get_trusted_certificates: messenger 	&lt;C:  const char *pn_messenger_get_trusted_certificates(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_incoming: messenger 	&lt;C:  int pn_messenger_incoming(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_incoming_subscription: messenger 	&lt;C:  pn_subscription_t *pn_messenger_incoming_subscription(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_incoming_tracker: messenger 	&lt;C:  pn_tracker_t pn_messenger_incoming_tracker(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_interrupt: messenger 	&lt;C:  int pn_messenger_interrupt(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_is_blocking: messenger 	&lt;C:  bool pn_messenger_is_blocking(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_is_passive: messenger 	&lt;C:  bool pn_messenger_is_passive(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_name: messenger 	&lt;C:  const char *pn_messenger_name(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_outgoing: messenger 	&lt;C:  int pn_messenger_outgoing(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_outgoing_tracker: messenger 	&lt;C:  pn_tracker_t pn_messenger_outgoing_tracker(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_put: messenger with: msg 	&lt;C:  int pn_messenger_put(pn_messenger_t *messenger, pn_message_t *msg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_receiving: messenger 	&lt;C:  int pn_messenger_receiving(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_recv: messenger with: limit 	&lt;C:  int pn_messenger_recv(pn_messenger_t *messenger, int limit)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_reject: messenger with: tracker with: flags 	&lt;C:  int pn_messenger_reject(pn_messenger_t *messenger, pn_tracker_t tracker, int flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_rewrite: messenger with: pattern with: address 	&lt;C:  int pn_messenger_rewrite(pn_messenger_t *messenger, const char *pattern, const char *address)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_route: messenger with: pattern with: address 	&lt;C:  int pn_messenger_route(pn_messenger_t *messenger, const char *pattern, const char *address)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_selectable: messenger 	&lt;C:  pn_selectable_t *pn_messenger_selectable(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_send: messenger with: n 	&lt;C:  int pn_messenger_send(pn_messenger_t *messenger, int n)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_blocking: messenger with: blocking 	&lt;C:  int pn_messenger_set_blocking(pn_messenger_t *messenger, bool blocking)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_certificate: messenger with: certificate 	&lt;C:  int pn_messenger_set_certificate(pn_messenger_t *messenger, const char *certificate)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_flags: messenger with: flags 	&lt;C:  int pn_messenger_set_flags(pn_messenger_t *messenger, const int flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_incoming_window: messenger with: window 	&lt;C:  int pn_messenger_set_incoming_window(pn_messenger_t *messenger, int window)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_outgoing_window: messenger with: window 	&lt;C:  int pn_messenger_set_outgoing_window(pn_messenger_t *messenger, int window)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_passive: messenger with: passive 	&lt;C:  int pn_messenger_set_passive(pn_messenger_t *messenger, bool passive)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_password: messenger with: password 	&lt;C:  int pn_messenger_set_password(pn_messenger_t *messenger, const char *password)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_private_key: messenger with: private_key 	&lt;C:  int pn_messenger_set_private_key(pn_messenger_t *messenger, const char *private_key)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_rcv_settle_mode: messenger with: mode 	&lt;C:  int pn_messenger_set_rcv_settle_mode(pn_messenger_t *messenger, const pn_rcv_settle_mode_t mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_snd_settle_mode: messenger with: mode 	&lt;C:  int pn_messenger_set_snd_settle_mode(pn_messenger_t *messenger, const pn_snd_settle_mode_t mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_ssl_peer_authentication_mode: messenger with: mode 	&lt;C:  int pn_messenger_set_ssl_peer_authentication_mode(pn_messenger_t *messenger, const pn_ssl_verify_mode_t mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_timeout: messenger with: timeout 	&lt;C:  int pn_messenger_set_timeout(pn_messenger_t *messenger, int timeout)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_tracer: messenger with: tracer 	&lt;C:  void pn_messenger_set_tracer(pn_messenger_t *messenger, pn_tracer_t tracer)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_set_trusted_certificates: messenger with: cert_db 	&lt;C:  int pn_messenger_set_trusted_certificates(pn_messenger_t *messenger, const char *cert_db)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_settle: messenger with: tracker with: flags 	&lt;C:  int pn_messenger_settle(pn_messenger_t *messenger, pn_tracker_t tracker, int flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_start: messenger 	&lt;C:  int pn_messenger_start(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_status: messenger with: tracker 	&lt;C:  pn_status_t pn_messenger_status(pn_messenger_t *messenger, pn_tracker_t tracker)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_stop: messenger 	&lt;C:  int pn_messenger_stop(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_stopped: messenger 	&lt;C:  bool pn_messenger_stopped(pn_messenger_t *messenger)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_subscribe: messenger with: source 	&lt;C:  pn_subscription_t *pn_messenger_subscribe(pn_messenger_t *messenger, const char *source)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_subscribe_ttl: messenger with: source with: timeout 	&lt;C:  pn_subscription_t * pn_messenger_subscribe_ttl(pn_messenger_t *messenger, const char *source, pn_seconds_t timeout)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_tracker_link: messenger with: tracker 	&lt;C:  pn_link_t *pn_messenger_tracker_link(pn_messenger_t *messenger, pn_tracker_t tracker)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_messenger_work: messenger with: timeout 	&lt;C:  int pn_messenger_work(pn_messenger_t *messenger, int timeout)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_subscription_address: sub 	&lt;C:  const char *pn_subscription_address(pn_subscription_t *sub)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_subscription_get_context: sub 	&lt;C:  void *pn_subscription_get_context(pn_subscription_t *sub)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_subscription_set_context: sub with: context 	&lt;C:  void pn_subscription_set_context(pn_subscription_t *sub, void *context)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="QpidProton">pn_type_name: type 	&lt;C:  const char *pn_type_name(pn_type_t type)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>ObjectStudio.QpidProton</class-id></initialize><initialize><class-id>ObjectStudio.QpidProtonDLL</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>ObjectStudio</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ObjectStudio Base</category><attributes><package>ObjectStudio Base Classes Preload</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>